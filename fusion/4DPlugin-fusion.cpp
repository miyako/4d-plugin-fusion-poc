/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-fusion.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : fusion
 #	author : miyako
 #	2020/05/19
 #
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-fusion.h"

#pragma mark -

#define CALLBACK_SLEEP_TIME 6
#define CALLBACK_IN_NEW_PROCESS 1

using namespace std;

static mutex mutex_process_id;
static process_number_t process_id;

static process_stack_size_t process_stack_size = 0;
static process_name_t process_name = (PA_Unichar *)"$\0f\0u\0s\0i\0o\0n\0\0\0";

static mutex mutex_process_should;
static bool process_should_terminate;
static bool process_should_resume;

static mutex mutex_fusion;

static mutex mutex_hook;
static mutex mutex_instance;

static mutex mutex_method_name;
static CUTF16String method_name;

namespace fusion {

std::vector<std::wstring> messages;
std::vector<int> events;

#if VERSIONWIN
HHOOK hook = NULL;
HINSTANCE instance = 0;
#endif

}

#if VERSIONWIN
int WINAPI DllMain(HINSTANCE hInstance, DWORD fdReason, PVOID pvReserved) {
    
    lock_guard<mutex> lock(mutex_instance);
    
    fusion::instance = hInstance;
    
    return TRUE;
}
#endif

void generateUuid(C_TEXT &returnValue) {
    
#if VERSIONWIN
    RPC_WSTR str;
    UUID uuid;
    
    if (UuidCreate(&uuid) == RPC_S_OK) {
        if (UuidToString(&uuid, &str) == RPC_S_OK) {
            size_t len = wcslen((const wchar_t *)str);
            
            std::vector<wchar_t>buf(len);
            memcpy(&buf[0], str, len * sizeof(wchar_t));
            _wcsupr((wchar_t *)&buf[0]);
            
            returnValue.setUTF16String((const PA_Unichar *)&buf[0], len);
            
            RpcStringFree(&str);
        }
    }
#else
#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
    returnValue.setUTF16String([[[NSUUID UUID]UUIDString]stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#else
    CFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault);
    NSString *uuid_str = (NSString *)CFUUIDCreateString(kCFAllocatorDefault, uuid);
    returnValue.setUTF16String([uuid_str stringByReplacingOccurrencesOfString : @"-" withString:@""]);
#endif
#endif
}

void OnStartup() {
    
#if VERSIONWIN
    
    lock_guard<mutex> lock(mutex_hook);
    
    fusion::hook = SetWindowsHookEx(
                                    WH_CALLWNDPROC,
                                    onEventCall,
                                    fusion::instance,
                                    0);
    
    listenerLoopStart();
    
#endif
}

void OnExit() {
    
#if VERSIONWIN
    
    listenerLoopFinish();
    
    UnhookWindowsHookEx(fusion::hook);
    
    fusion::hook = NULL;
    
#endif
}

#if VERSIONWIN
LRESULT CALLBACK onEventCall(int code, WPARAM wParam, LPARAM lParam)
{
    if (code == HC_ACTION)
    {
        CWPSTRUCT *pcwp = (CWPSTRUCT*)lParam;
        
        UINT event = pcwp->message;
        
        if (pcwp->message == EM_REPLACESEL) {
            
            std::wstring str((const wchar_t *)pcwp->lParam);
            
            lock_guard<mutex> lock(mutex_fusion);
            
            fusion::messages.push_back(str);
            fusion::events.push_back(EM_REPLACESEL);
            
            listenerLoopExecute();
        }
        
    }
    
    return CallNextHookEx(fusion::hook, code, wParam, lParam);
}
#endif

#pragma mark -

void listenerLoop() {
    
    using namespace std;
    
    if(1)
    {
        lock_guard<mutex> lock(mutex_process_should);
        
        process_should_terminate = false;
    }
    
    /* Current process returns 0 for PA_NewProcess */
    process_number_t currentProcessNumber = PA_GetCurrentProcessNumber();
    
    while(!PA_IsProcessDying())
    {
        PA_YieldAbsolute();
        
        bool should_resume;
        bool should_terminate;
        
        if(1)
        {
            lock_guard<mutex> lock(mutex_process_should);
            
            should_resume = process_should_resume;
            should_terminate = process_should_terminate;
        }
        
        if(should_resume)
        {
            size_t count;
            
            if(1)
            {
                lock_guard<mutex> lock(mutex_fusion);
                
                count = fusion::events.size();
            }
            
            while(count)
            {
                PA_YieldAbsolute();
                
                if (CALLBACK_IN_NEW_PROCESS)
                {
                    C_TEXT processName;
                    generateUuid(processName);
                    PA_NewProcess((void *)listenerLoopExecuteMethod,
                                  0,
                                  (PA_Unichar *)processName.getUTF16StringPtr());
                }
                else
                {
                    listenerLoopExecuteMethod();
                }
                
                if(should_terminate)
                    break;
                
                if(1)
                {
                    lock_guard<mutex> lock(mutex_fusion);
                    
                    count = fusion::events.size();
                }
                
                should_terminate = process_should_terminate;
            }
            
            if(1)
            {
                std::lock_guard<std::mutex> lock(mutex_process_should);
                
                should_resume = false;
            }
            
        }else
        {
            PA_PutProcessToSleep(currentProcessNumber, CALLBACK_SLEEP_TIME);
        }
        
        should_terminate = process_should_terminate;
        
        
        if(should_terminate)
            break;
    }
    
    if(1)
    {
        lock_guard<mutex> lock(mutex_fusion);
        
        fusion::messages.clear();
        fusion::events.clear();
    }
    
    if(1)
    {
        lock_guard<mutex> lock(mutex_process_id);
        
        process_id = 0;
    }
    
    PA_KillProcess();
}

void listenerLoopStart() {
    
    if (!process_id) {
        
        using namespace std;
        
        lock_guard<mutex> lock(mutex_process_id);
        
        process_id = PA_NewProcess((void *)listenerLoop,
                                   process_stack_size,
                                   process_name);
    }
}

void listenerLoopFinish() {
    
    if(process_id)
    {
        using namespace std;
        
        lock_guard<mutex> lock(mutex_process_should);
        
        process_should_terminate = true;
        process_should_resume = true;
    }
}

void listenerLoopExecute() {
    
    if (process_id)
    {
        using namespace std;
        
        lock_guard<mutex> lock(mutex_process_should);
        
        process_should_terminate = false;
        process_should_resume = true;
    }
}

void listenerLoopExecuteMethod() {
    
    using namespace std;
    
    wstring message;
    int event;
    
    if(1)
    {
        lock_guard<mutex> lock(mutex_fusion);
        
        vector<wstring>::iterator im;
        vector<int>::iterator ie;
        
        im = fusion::messages.begin();
        ie = fusion::events.begin();
        
        message = *im;
        event = *ie;
        
        fusion::messages.erase(im);
        fusion::events.erase(ie);
    }
    
    fusion_invoke_method(event, message);
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
    try
    {
        switch(selector)
        {
            case kInitPlugin :
            case kServerInitPlugin :
                OnStartup();
                break;
                
            case kDeinitPlugin :
                OnExit();
                break;
                
                // --- fusion
                
            case 1 :
                fusion_send_message(params);
                break;
            case 2 :
                fusion_on_event_call(params);
                break;
        }
        
    }
    catch(...)
    {
        
    }
}

#pragma mark -

static void set_text_to_pasteboard(std::wstring &value) {
    
    PA_Variable args[1];
    
    args[0] = PA_CreateVariable(eVK_Text);
    
    PA_Unistring str = PA_CreateUnistring((PA_Unichar *)value.c_str());
    
    PA_SetStringVariable (&args[0], &str);
    
    PA_ExecuteCommandByID/*threadSafe*/(
                                        CMD_SET_TEXT_TO_PASTEBOARD/*not threadSafe*/,
                                        args, 1);
    PA_ClearVariable(&args[0]);
}

#pragma mark -

void fusion_invoke_method(int event, std::wstring& message) {
    
    method_id_t methodId = PA_GetMethodID((PA_Unichar *)method_name.c_str());
    
    if (methodId)
    {
        PA_Variable    params[2];
        params[0] = PA_CreateVariable(eVK_Longint);
        params[1] = PA_CreateVariable(eVK_Unistring);
        
        PA_Unistring str = PA_CreateUnistring((PA_Unichar *)message.c_str());
        
        PA_SetLongintVariable(&params[0], event);
        PA_SetStringVariable (&params[1], &str);
        
        PA_ExecuteMethodByID(methodId, params, 2);
        
        PA_ClearVariable(&params[0]);
        PA_ClearVariable(&params[1]);
        
    }
    
}

void invoke_action(const char *action, int target) {
    
    /*
     * PA_ExecuteCommandByID no longer works in PA_NewProcess
     */
    
    PA_Variable args[2];
    
    args[0] = PA_CreateVariable(eVK_Text);
    args[1] = PA_CreateVariable(eVK_Longint);
    
    PA_Unistring command = PA_CreateUnistring((PA_Unichar *)action);
    
    PA_SetStringVariable (&args[0], &command);
    PA_SetLongintVariable(&args[1], target);
    
    PA_ExecuteCommandByID(
                          CMD_INVOKE_ACTION,
                          args, 2);
    
    PA_ClearVariable(&args[0]);
    PA_ClearVariable(&args[1]);
}

void invoke_copy_action() {
    
    invoke_action(ak_copy);
    
}

void invoke_paste_action() {
    
    invoke_action(ak_paste);
    
}

#pragma mark -

void fusion_send_message(PA_PluginParameters params) {
    
    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    
    if(options) {
        
        PA_WindowRef window = reinterpret_cast<PA_WindowRef>((int)ob_get_n(options, L"window"));
        
        if(window) {
            
#if VERSIONWIN
            
            UINT event = (int)ob_get_n(options, L"event");
            HWND hwnd = (HWND)PA_GetHWND(window);
            
            switch (event) {
                    
                case EM_REPLACESEL:
                {
                    WPARAM wparam = (WPARAM)0;
                    CUTF16String value;
                    ob_get_a(options, L"value", &value);
                    LPARAM lparam = (LPARAM)value.c_str();
                    
                    LRESULT returnValue = SendMessage(
                                                      hwnd,
                                                      event,
                                                      wparam,
                                                      lparam
                                                      );
                }
                    break;

                default:
                    break;
            }
#endif
        }
        
    }
    
}

static void fusion_on_event_call(PA_PluginParameters params) {
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT t;
    t.fromParamAtIndex(pParams, 1);
    
    lock_guard<mutex> lock(mutex_method_name);
    
    t.copyUTF16String(&method_name);
}
